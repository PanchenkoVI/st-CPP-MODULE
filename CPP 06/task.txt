#===============>
Бонусные правила

Для каждого упражнения, любая случайная ситуация решается конкретным cast. Оценка будет проверена если вы выбрали соответствующий ожидаемый cast.
#===============>
Exercise 00: Scalar conversion

Turn-in directory :ex00/
Files to turn in :Any file you need and a Makefile
Allowed functions : Любые функции конвертации из строки в инт, флоат или дабл. Это поможет, но не сделает всю работу.

Напишите программу которая принимает строку в представлении С++ литерального значения (в своей наиболее распространенной форме) как парметр. Этот литерал должен принадлежать одному из следующих скалярных типо: char, int, float or double. Будет использоваться только десятичная система счисления.

Например char литеральное значение: 'c', 'a' ... Для упрощения, пожалуйста запишите это: не отображаемые символы не могут быть переданы в качестве параметра вашей программе, и если преобразование в символ не отображается, вместо этого выведите уведомление.

Например int литеральное значение: 0, -42, 42...
Например float литеральное значение: 0.0f, -4.2f, 4.2f... Вы также примете эти псевдо-литералы, как вы знаете, для науки: -inff, +inff and nanf.
Например double литеральное значение: 0.0,-4.2,4.2... Вы также примете эти псевдо-литералы, как вы знаете, для прикола: -inf, +inf and nan.
Ваша программа должна обнаружить литеральный тип, преобразуйте этот литерал в правильный тип (итак это больше не строка), затем преобразуйте его явно в каждый из трех других типов и отобразите результат использования того же форматирования, что и ниже. Если преобразование не имеет смысла или переполняется, покажите, что преобразование невозможно. Вы можете включить любой заголовок, необходимый для обработки числовых ограничений и специальных значений. 
#===============>
Exercise 01: Serialization

Turn-in directory :ex01/
Files to turn in : Any file you need and a Makefile
Allowed functions : None

Напишите функцию "void * serialize(void);". Эта функция будет возвращать адресс на heap последовательностей байтов, что представляют фрагмент сериализованных данных. Сериализованные данные представляют собой конкатенацию случайного массива из 8 буквенно-цифровых символов, случайного целого числа и второго случайного массива из 8 буквенно-цифровых символов. Не стесняйтесь использовать все, что вам нравится, чтобы генерировать случайные значения.

Напишите функцию "Data * deserialize(void * raw);". Эта функция будет десериализовать исходные данные в Data структуре "struct Data { std::string s1; intn; std::string s2; };"  аллоцированные в heap.

Оберните эти две функции в программу, которая докажет, что все работает так, как задумано.
#===============>
Exercise 02: Identify real type

Turn-in directory :ex02/
Files to turn in :Any file you need and a Makefile
Allowed functions :None

Создайте класс Base который обладает единственным публичным виртуальным деструктором. Создайте 3 пустых класса A, B and C которые публично наследуются от Base.

Напишите функцию "Base * generate(void);" которая рандомно создает экземпляр класса A,B or C и возвращает указатель Base. Свободно используйте все для рандома.

Напишите функцию "void identify_from_pointer(Base * p);" которая отображает "A","B" or "C" в соответствии с реальным типом p.

Напишите функцию "void identify_from_reference( Base & p);" которая отображает "A","B" or "C" в соответствии с реальным типом p.

Заверните эти 3 функции в программу которая докажет что все работает как предназначенно. Подключение <typeinfo> запрещено.