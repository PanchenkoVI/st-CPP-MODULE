#===============>
Упражнение 00: куча четвероногих

Exercise 00: Heap of quadrupeds
Turn-in directory : ex00/
Files to turn in : Pony.cpp Pony.hpp main.cpp
Forbidden functions : None

Начать с простого.
Составьте "класс пони", содержащий все, что, по вашему мнению, адекватно описывает пони. Затем создайте две функции, "ponyOnTheHeap" и "ponyOnTheStack", в которых вы будете выделять "пони" и заставлять его делать некоторые вещи.
Конечно, в первом случае пони должен быть помещен в кучу, а во втором - в стек.
Вы предоставите main достаточно кода, чтобы доказать, что то, что вы сделали, работает так, как задумано.
В обоих случаях "Pony" объекты не должны существовать после того, как функция отключит управление. (Ваш главный тоже должен будет продемонстрировать это во время коррекции!)

#===============>
Exercise 01 : Plumbing problem

Turn-in directory : ex01/
Files to turn in : ex01.cpp
Forbidden functions : None

Опять же, простое упражнение.
Вы должны включить следующую функцию, исправив содержащуюся в ней утечку памяти.
Конечно, вы должны играть с выделением/освобождением памяти здесь. Простое удаление переменной или иное манипулирование проблемой, фактически не разбирая ее, будет считаться неправильным ответом.
void memoryLeak()
{
    std::string* panthere = new std::string("String panthere");
    std::cout << *panthere << std::endl;
}

#===============>
Exercise 02 : Plucking some brains

Turn-in directory : ex02/
Files to turn in : Zombie.cpp Zombie.hpp ZombieEvent.cpp ZombieEvent.hpp main.cpp
Forbidden functions : None

Во-первых, сделайте класс Zombie. Сделайте так, чтобы он содержал тип и имя (по крайней мере), а также добавьте функцию - член announce(), которая будет выводить что-то вроде :
<name (type)> Braiiiiiiinnnssss...
Все, что вы хотите, на самом деле, пока вы выводите имя и тип зомби.

После этого вы создадите класс "ZombieEvent". Он будет иметь функцию "setZombieType", которая будет хранить тип в объекте, и функцию "Zombie* newZombie(std::stringname)", которая создаст зомби с выбранным типом, назовет его и вернет.

Вы также создадите функцию "randomChump", которая создаст "Zombie" со случайным именем и заставит его "announce" о себе. Какой бы "random" метод вы ни выбрали, действительно случайные имена или случайный выбор из пула имен, это прекрасно.

Вы должны включить полную программу, включая основную, с достаточным количеством доказательств того, что то, что вы сделали, работает так, как требуется. Например, сделайте так, чтобы ваши вновь созданные зомби объявили о себе.

Теперь реальный смысл упражнения : ваши зомби должны быть уничтожены в соответствующее время (так, когда они больше не нужны). Они также должны быть распределены соответствующим образом : в некоторых случаях уместно иметь их в стеке, в других случаях куча является лучшим выбором. Вам придется оправдать то, что вы сделали, чтобы получить положительную оценку.

#===============>
Exercise 03 : Moar brainz !

Turn-in directory : ex03/
Files to turn in : Zombie.cpp Zombie.hpp ZombieHorde.cpp ZombieHorde.hpp main.cpp
Forbidden functions : None

Повторно используя класс Zombie, который вы сделали в предыдущем упражнении, создайте "ZombieHorde" класс.

Этот класс будет иметь конструктор, который принимает целое число N. При создании он должен выделить N зомби-объектов со случайными именами (то же понятие "random", что и раньше) и сохранить их. Затем он будет иметь функцию announce(), которая вызывает функцию announce() для каждого из содержащихся в ней объектов зомби.

Вы должны распределить все зомби-объекты в одном выделении и освободить их, когда ZombieHorde будет уничтожена.

Как обычно, снабдите main тестами и обоснуйте свой выбор.

#===============>
Exercise 04 : HI THIS IS BRAIN

Turn-in directory : ex04/
Files to turn in : ex04.cpp
Forbidden functions : None

Сделайте программу, в которой вы создадите строку, содержащую "HI THIS IS BRAIN", указатель на нее и ссылку на нее.
Затем вы будете отображать его с помощью указателя и, наконец, отображать его с помощью ссылки.
Вот и все, никаких фокусов.

#===============>
Exercise 05 : HI BRAIN THIS IS HUMAN

Turn-in directory : ex05/
Files to turn in : Brain.cpp Brain.hpp Human.cpp Human.hpp main.cpp
Forbidden functions : None

Создайте класс мозга, с тем, что вы считаете подходящим для мозга. Он будет иметь функцию identify (), которая возвращает строку, содержащую адрес мозга в памяти, в шестнадцатеричном формате, с префиксом 0x (например, "0x194F87EA").
Затем создайте человеческий класс, который имеет постоянный атрибут мозга, с тем же временем жизни. У него есть функция identify (), которая просто вызывает функцию identify() своего мозга и возвращает ее результат.
Теперь сделайте так, чтобы этот код компилировался и отображал два одинаковых адреса :

int main()
{
    Human bob;
    std::cout << bob.identify() << std::endl;
    std::cout << bob.getBrain().identify() << std::endl;
}

Этот код должен быть включен в качестве основного, и все, что вы добавляете к классам Human или Brain, чтобы заставить его работать, должно быть оправдано (с другим аргументом, чем "Er, yeah, well, i fiddled with it until it worked").

#===============>
Exercise 06 : Unnecessary violence

Turn-in directory : ex06/
Files to turn in : Weapon.cpp Weapon.hpp HumanA.cpp HumanA.hpp HumanB.cpp HumanB.hpp main.cpp
Forbidden functions : None

Создайте класс Weapon, который имеет тип string, и getType, который возвращает ссылку const на эту строку. Также имеет setType.
Теперь создайте два класса, HumanA и HumanB, которые оба имеют Weapon, имя и функцию attack(), которая отображает что-то вроде: NAME attacks with his WEAPON_TYPE

Сделайте так, чтобы следующий код производил атаки с помощью "crude spiked club", а затем "some other type of club", в обоих тестовых случаях:

int main()
{
    {
        Weapon club = Weapon("crude spiked club");
        HumanA bob("Bob", club);
        bob.attack();
        club.setType("some other type of club");
        bob.attack();
    }
    {
        Weapon club = Weapon("crude spiked club");
        HumanB jim("Jim");
        jim.setWeapon(club);
        jim.attack();
        club.setType("some other type of club");
        jim.attack();
    }
}

В каком случае уместно хранить оружие в качестве указки ? В качестве ссылки ? Почему? Является ли это лучшим выбором в свете того, что спрашивается ? Вот вопросы, которые вы должны задать себе перед выполнением этого упражнения.

#===============>
Exercise 07 : Sed is for losers

Turn-in directory : ex07/
Files to turn in : Makefile, and whatever else you need
Forbidden functions : None

Сделайте программу под названием replace, которая принимает имя файла и две строки, назовем их s1 и s2, которые не являются пустыми.

Он откроет файл и запишет его содержимое в файл FILENAME.replace, заменив каждое вхождение s1 на s2.

Конечно, вы будете обрабатывать ошибки как можно лучше и не использовать функции манипулирования файлами C, потому что это было бы мошенничеством, а мошенничество-это плохо, м'Кей?

Вы включите некоторые тестовые файлы, чтобы показать работу вашей программы.